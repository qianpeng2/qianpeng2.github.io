---
title: 设计模式之单例模式
date: 2019-07-01 16:56:29
tags: 设计模式,单例模式
categories: 设计模式
---
  单例模式是设计模式中的一种，比较简单也比较经典，面试中也会经常问到，下面就简单梳理下。
  
  单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。
  
  单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。
### 1、一个简单的单例模式
{% codeblock lang:java %}
public class TaskManager {

    // 这个成员变量必须是 static，因为方法 getInstance 是static的
    // 且那个方法是返回的就是这个成员变量
    private static TaskManager tm = null;

    // 单例模式必须将构造方法设置为私有，不能以 new 的方式生成新的实例
    private TaskManager() {
        // 里面可以不操作或者随便怎么处理都行
    }


    /**
     * 为了给外部调用，必须封装一个public的方法，其修饰符设置为 static
     * 外部通过  TaskManager.getInstance() 来调用，获取 TaskManager 的唯一一个实例(对象)
     * 静态成员变量在类加载的时候会被初始化的
     *
     * @return
     */
    public static TaskManager getInstance() {

        if (tm == null) {
            tm = new TaskManager();
            return tm;
        }
        return tm;
    }
}
{% endcodeblock %}

### 2、线程安全的问题
  以下情况会造成系统中出现多个实例: 1)当外部多个线程同时调用getInstance的时候; 2)多个线程虽然先后调用，但是这个对象的创建时间太长,在第一个线程完成创建对象之前，第二个线程的方法调用到达，tm == null 条件仍然成立，此时会创建出多个对象，不再是单例模式了
  
  单例模式有2种类型，懒汉式和饿汉式，根据实例的创建方式是否是懒加载来划分
         

### 3、饿汉式
  此种情况下，不会发生线程安全的问题，因为唯一的实例在类加载完成后便已产生。
{% codeblock lang:java %}
public class EagerSingleton {

    private String name;

    // 当类被加载的时候，静态成员变量 instance 就会被初始化
    // 此时类 EagerSingleton 的私有构造方法被调用，单例类的唯一实例将被成功创建
    // 可以保证在调用的时候，这个实例的唯一性，因为外部调用发生在类加载完成之后
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {
        
        System.out.println(instance);// 此时instance 为null
        this.setName("Tom");
        // 构造方法完成之时，这个对象被创建出来了，放在了堆中，但是这个对象还没有赋给 instance 这个引用，instance 仍为null
        
    }

    public static EagerSingleton getInstance() {
        return instance;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
{% endcodeblock %}

### 4、懒汉式
  下面提供一个简单的实现。
{% codeblock lang:java %}
public class LazySingleton {

    private static LazySingleton instance = null;

    /**
     * 构造方法设置为私有
     */
    private LazySingleton() {

    }

    /**
     * 同步的方式实现多线程环境下，该类对外只提供一个实例
     * 重量级锁
     *
     * @return
     */
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
            return instance;
        }
        return instance;
    }
}
{% endcodeblock %}
  懒汉式的问题：如果在 方法 上加锁，虽然能够解决多线程的问题，但是每次这个 getInstance 方法被调用的时候都要进行同步，严重影响性能，没有必要，因为只要调用一次，那么这个唯一的对象就创建出来了
### 5、懒汉式单例的一种改进
  为了提升性能，同步级别由方法级别改为代码块级别。
{% codeblock lang:java %}
public class LazySingleton {

    private static LazySingleton instance = null;

    /**
     * 构造方法设置为私有
     */
    private LazySingleton() {

    }

    /**
     * 同步的方式实现多线程环境下，该类对外只提供一个实例
     * 重量级锁
     *
     * @return
     */
    public static LazySingleton getInstance() { 
        if (instance == null) {
            // 只锁住部分代码
            synchronized (LazySingleton.class) {
                instance = new LazySingleton();
            }
            return instance;
        }
        return instance;
    }
}
{% endcodeblock %}
### 5、上述改进可能出现的问题
  上述改进看起来没问题，但是在某些情况下是线程不安全的(如:对象的创建时间过长，多个线程同时启动的时候，后面的线程没有感知到前面的线程已经创建好了对象)

### 6、解决方法-双重校验锁
  此时可以通过 double-check Locking(双重校验锁)解决，也就是在同步代码块内再做一次判空
{% codeblock lang:java %}
public class LazySingleton {

    // 加了 volatile 之后性能更好,不加这个关键字,也不影响结果
    private static volatile LazySingleton instance = null;

    /**
     * 构造方法设置为私有
     */
    private LazySingleton() throws InterruptedException {

        // 模拟对象的创建时间需要1s
        Thread.sleep(1000);
    }

    /**
     * 同步的方式实现多线程环境下，该类对外只提供一个实例
     * 重量级锁
     *
     * @return
     */
    public static LazySingleton getInstance() throws InterruptedException {
        if (instance == null) {

            /**
             * 在之前的基础上进一步改进
             * 在同步代码块中再次新增一个判断  if (instance == null)
             * 这种方式称为 双重检查锁定 ——double check Locking
             */
            synchronized (LazySingleton.class) {
                // 还需要做判断的，因为第一个if检查可能被多个线程执行过，多个线程在进入同步代码块之前第一个if都成立
                // Java 1.5 之后有一个 关键字 volatile，被修饰的成员变量 一旦被修改，则对所有线程可见
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
            return instance;
        }
        return instance;
    }
}  
{% endcodeblock %}

